(function() {
  var HintCreator, acceptMatchThreshold, extractRuntimeErrorDetails, extractTranspileErrorDetails, getRuntimeHint, getTranspileHint, ranges, scoreFuzziness, string_score, _, _ref, _ref1, _ref2,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ranges = require('./ranges');

  string_score = require('string_score');

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  scoreFuzziness = 0.8;

  acceptMatchThreshold = 0.5;

  module.exports.createUserCodeProblem = function(options) {
    var config, id, kind, p, reporter, _ref3, _ref4, _ref5, _ref6;
    if (options == null) {
      options = {};
    }
    if (options.aether == null) {
      options.aether = this;
    }
    if (options.type === 'transpile' && options.error) {
      extractTranspileErrorDetails(options);
    }
    if (options.type === 'runtime') {
      extractRuntimeErrorDetails(options);
    }
    reporter = options.reporter || 'unknown';
    kind = options.kind || 'Unknown';
    id = reporter + '_' + kind;
    config = ((_ref3 = options.aether) != null ? (_ref4 = _ref3.options) != null ? (_ref5 = _ref4.problems) != null ? _ref5[id] : void 0 : void 0 : void 0) || {};
    p = {
      isUserCodeProblem: true
    };
    p.id = id;
    p.level = config.level || options.level || 'error';
    p.type = options.type || 'generic';
    p.message = config.message || options.message || ("Unknown " + p.type + " " + p.level);
    p.hint = config.hint || options.hint || '';
    p.range = options.range;
    p.userInfo = (_ref6 = options.userInfo) != null ? _ref6 : {};
    return p;
  };

  extractTranspileErrorDetails = function(options) {
    var code, codePrefix, col, columnOffset, doubleVar, end, endCol, error, errorContext, languageID, line, lineOffset, originalLines, range, rng, row, start, startCol, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    code = options.code || '';
    codePrefix = options.codePrefix || '';
    error = options.error;
    options.message = error.message;
    errorContext = options.problemContext || ((_ref3 = options.aether) != null ? (_ref4 = _ref3.options) != null ? _ref4.problemContext : void 0 : void 0);
    languageID = (_ref5 = options.aether) != null ? (_ref6 = _ref5.options) != null ? _ref6.language : void 0 : void 0;
    originalLines = code.slice(codePrefix.length).split('\n');
    lineOffset = codePrefix.split('\n').length - 1;
    switch (options.reporter) {
      case 'jshint':
        if (options.message == null) {
          options.message = error.reason;
        }
        if (options.kind == null) {
          options.kind = error.code;
        }
        if (doubleVar = options.message.match(/'([\w]+)' is already defined\./)) {
          options.hint = "Don't use the 'var' keyword for '" + doubleVar[1] + "' the second time.";
        }
        if (!options.level) {
          options.level = {
            E: 'error',
            W: 'warning',
            I: 'info'
          }[error.code[0]];
        }
        line = error.line - codePrefix.split('\n').length;
        if (line >= 0) {
          if ((_ref7 = error.evidence) != null ? _ref7.length : void 0) {
            startCol = originalLines[line].indexOf(error.evidence);
            endCol = startCol + error.evidence.length;
          } else {
            _ref8 = [0, originalLines[line].length - 1], startCol = _ref8[0], endCol = _ref8[1];
          }
          options.range = [ranges.rowColToPos(line, startCol, code, codePrefix), ranges.rowColToPos(line, endCol, code, codePrefix)];
        } else {
          options.range = [ranges.offsetToPos(0, code, codePrefix), ranges.offsetToPos(code.length - 1, code, codePrefix)];
        }
        break;
      case 'esprima':
        options.range = [ranges.rowColToPos(error.lineNumber - 1 - lineOffset, error.column - 1, code, codePrefix), ranges.rowColToPos(error.lineNumber - 1 - lineOffset, error.column, code, codePrefix)];
        break;
      case 'acorn_loose':
        null;
        break;
      case 'csredux':
        options.range = [ranges.rowColToPos(error.lineNumber - 1 - lineOffset, error.column - 1, code, codePrefix), ranges.rowColToPos(error.lineNumber - 1 - lineOffset, error.column, code, codePrefix)];
        break;
      case 'aether':
        null;
        break;
      case 'closer':
        if (error.startOffset && error.endOffset) {
          range = ranges.offsetsToRange(error.startOffset, error.endOffset, code);
          options.range = [range.start, range.end];
        }
        break;
      case 'lua2js':
        if (options.message == null) {
          options.message = error.message;
        }
        rng = ranges.offsetsToRange(error.offset, error.offset, code, '');
        options.range = [rng.start, rng.end];
        break;
      case 'filbert':
        if (error.loc) {
          columnOffset = 0;
          row = error.loc.line - lineOffset - 1;
          col = error.loc.column - columnOffset;
          start = ranges.rowColToPos(row, col, code, codePrefix);
          end = ranges.rowColToPos(row, col + error.raisedAt - error.pos, code, codePrefix);
          options.range = [start, end];
        }
        break;
      case 'iota':
        null;
        break;
      case 'cashew':
        options.range = [ranges.offsetToPos(error.range[0], code, codePrefix), ranges.offsetToPos(error.range[1], code, codePrefix)];
        options.hint = error.message;
        break;
      default:
        console.warn("Unhandled UserCodeProblem reporter", options.reporter);
    }
    options.hint = error.hint || getTranspileHint(options.message, errorContext, languageID, options.aether.raw, options.range, (_ref9 = options.aether.options) != null ? _ref9.simpleLoops : void 0);
    return options;
  };

  getTranspileHint = function(msg, context, languageID, code, range, simpleLoops) {
    var c, codeSnippet, firstQuoteIndex, hintCreator, index, lineStart, lineStartLow, nonAlphNumMatch, parens, prevIndex, quoteCharacter, _i, _len;
    if (simpleLoops == null) {
      simpleLoops = false;
    }
    if ((msg === "Unterminated string constant" || msg === "Unclosed string.") && (range != null)) {
      codeSnippet = code.substring(range[0].ofs, range[1].ofs);
      firstQuoteIndex = codeSnippet.search(/['"]/);
      if (firstQuoteIndex !== -1) {
        quoteCharacter = codeSnippet[firstQuoteIndex];
        codeSnippet = codeSnippet.slice(firstQuoteIndex + 1);
        if (nonAlphNumMatch = codeSnippet.match(/[^\w]/)) {
          codeSnippet = codeSnippet.substring(0, nonAlphNumMatch.index);
        }
        return "Missing a quotation mark. Try `" + quoteCharacter + codeSnippet + quoteCharacter + "`";
      }
    } else if (msg === "Unexpected indent") {
      if (range != null) {
        index = range[0].ofs;
        while (index > 0 && /\s/.test(code[index])) {
          index--;
        }
        if (index >= 3 && /else/.test(code.substring(index - 3, index + 1))) {
          return "You are missing a ':' after 'else'. Try `else:`";
        }
      }
      return "Code needs to line up.";
    } else if (((msg.indexOf("Unexpected token") >= 0) || (msg.indexOf("Unexpected identifier") >= 0)) && (context != null)) {
      codeSnippet = code.substring(range[0].ofs, range[1].ofs);
      lineStart = code.substring(range[0].ofs - range[0].col, range[0].ofs);
      lineStartLow = lineStart.toLowerCase();
      hintCreator = new HintCreator(context, languageID);
      if (lineStart.indexOf(hintCreator.thisValue) === 0 && lineStart.trim().length < lineStart.length) {
        if (codeSnippet.indexOf(hintCreator.thisValue) === 0) {
          return "Delete extra `" + hintCreator.thisValue + "`";
        } else {
          return hintCreator.getReferenceErrorHint(codeSnippet);
        }
      }
      prevIndex = range[0].ofs - 1;
      while (prevIndex >= 0 && /[\t ]/.test(code[prevIndex])) {
        prevIndex--;
      }
      if (prevIndex >= 0 && code[prevIndex] === ')') {
        if (codeSnippet === ')') {
          return "Delete extra `)`";
        } else if (!/^\s*$/.test(codeSnippet)) {
          return "Put each command on a separate line";
        }
      }
      parens = 0;
      for (_i = 0, _len = lineStart.length; _i < _len; _i++) {
        c = lineStart[_i];
        parens += (c === '(' ? 1 : c === ')' ? -1 : 0);
      }
      if (parens !== 0) {
        return "Your parentheses must match.";
      }
      if (simpleLoops && codeSnippet === ':' && lineStart !== lineStartLow && lineStartLow === 'loop') {
        return "Should be lowercase. Try `loop`";
      }
      if (/^\s*if /.test(lineStart)) {
        if (codeSnippet === ':') {
          return "Your if statement is missing a test clause. Try `if True:`";
        } else if (/^\s*$/.test(codeSnippet)) {
          return "You are missing a ':' after '" + lineStart + "'. Try `" + lineStart + ":`";
        }
      }
      if (/Unexpected [token|identifier]/.test(msg)) {
        return "There is a problem with your code.";
      }
    }
  };

  extractRuntimeErrorDetails = function(options) {
    var error, lineNumber, _ref3;
    if (error = options.error) {
      if (options.kind == null) {
        options.kind = error.name;
      }
      if (options.aether.options.useInterpreter) {
        options.message = error.toString();
      } else {
        options.message = error.message || error.toString();
      }
      console.log("Extracting", error);
      options.hint = error.hint || getRuntimeHint(options);
      if (options.level == null) {
        options.level = error.level;
      }
      if (options.userInfo == null) {
        options.userInfo = error.userInfo;
      }
    }
    if (options.range == null) {
      options.range = (_ref3 = options.aether) != null ? _ref3.lastStatementRange : void 0;
    }
    if (options.range != null) {
      lineNumber = options.range[0].row + 1;
      if (options.message.search(/^Line \d+/) !== -1) {
        return options.message = options.message.replace(/^Line \d+/, function(match, n) {
          return "Line " + lineNumber;
        });
      } else {
        return options.message = "Line " + lineNumber + ": " + options.message;
      }
    }
  };

  getRuntimeHint = function(options) {
    var code, context, hint, hintCreator, index, languageID, simpleLoops, _ref3, _ref4, _ref5;
    code = options.aether.raw || '';
    context = options.problemContext || ((_ref3 = options.aether.options) != null ? _ref3.problemContext : void 0);
    languageID = (_ref4 = options.aether.options) != null ? _ref4.language : void 0;
    simpleLoops = (_ref5 = options.aether.options) != null ? _ref5.simpleLoops : void 0;
    if (options.message === "RangeError: Maximum call stack size exceeded") {
      return "Did you call a function recursively?";
    }
    if (simpleLoops && languageID === 'python' && /ReferenceError: loop is not defined/.test(options.message)) {
      if (options.range != null) {
        index = options.range[1].ofs;
        while (index < code.length && /[^\n:]/.test(code[index])) {
          index++;
        }
        if (index >= code.length || code[index] === '\n') {
          hint = "You are missing a ':' after 'loop'. Try `loop:`";
        }
      } else {
        hint = "Are you missing a ':' after 'loop'? Try `loop:`";
      }
      return hint;
    }
    if (context == null) {
      return;
    }
    hintCreator = new HintCreator(context, languageID);
    return hintCreator.getHint(code, options);
  };

  HintCreator = (function() {
    function HintCreator(context, languageID) {
      this.thisValue = (function() {
        switch (languageID) {
          case 'python':
            return 'self';
          case 'cofeescript':
            return '@';
          default:
            return 'this';
        }
      })();
      this.realThisValueAccess = (function() {
        switch (languageID) {
          case 'python':
            return 'self.';
          case 'cofeescript':
            return '@';
          default:
            return 'this.';
        }
      })();
      this.thisValueAccess = (function() {
        switch (languageID) {
          case 'python':
            return 'hero.';
          case 'cofeescript':
            return 'hero.';
          case 'lua':
            return 'hero:';
          default:
            return 'hero.';
        }
      })();
      this.newVariableTemplate = (function() {
        switch (languageID) {
          case 'javascript':
            return _.template('var <%= name %> = ');
          default:
            return _.template('<%= name %> = ');
        }
      })();
      this.methodRegex = (function() {
        switch (languageID) {
          case 'python':
            return new RegExp("self\\.(\\w+)\\s*\\(");
          case 'cofeescript':
            return new RegExp("@(\\w+)\\s*\\(");
          default:
            return new RegExp("this\\.(\\w+)\\(");
        }
      })();
      this.context = context != null ? context : {};
    }

    HintCreator.prototype.getHint = function(code, _arg) {
      var aether, ast, candidatesLow, codeSnippet, error, extra, hint, idx, line, message, missingMethodMatch, missingProperty, missingReference, newName, nullObjMatch, nullObjRegex, range, s, sm, target;
      message = _arg.message, range = _arg.range, error = _arg.error, aether = _arg.aether;
      if (this.context == null) {
        return;
      }
      if (error.code === 'UndefinedVariable' && error.when === 'write' && aether.language.id === 'javascript') {
        return "Missing `var`. Use `var " + error.ident + " =` to make a new variable.";
      }
      if (error.code === "CallNonFunction") {
        ast = error.targetAst;
        if (ast.type === "MemberExpression" && !ast.computed) {
          extra = "";
          target = ast.property.name;
          if (error.candidates != null) {
            candidatesLow = (function() {
              var _i, _len, _ref3, _results;
              _ref3 = error.candidates;
              _results = [];
              for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                s = _ref3[_i];
                _results.push(s.toLowerCase());
              }
              return _results;
            })();
            idx = candidatesLow.indexOf(target.toLowerCase());
            if (idx !== -1) {
              newName = error.targetName.replace(target, error.candidates[idx]);
              return "Look out for capitalization: `" + error.targetName + "` should be `" + newName + "`.";
            }
            sm = this.getScoreMatch(target, [
              {
                candidates: error.candidates,
                msgFormatFn: function(match) {
                  return match;
                }
              }
            ]);
            if (sm != null) {
              newName = error.targetName.replace(target, sm);
              return "Look out for spelling issues: did you mean `" + newName + "` instead of `" + error.targetName + "`?";
            }
          }
          return "`" + ast.object.srcName + "` has no method `" + ast.property.name + "`.";
        }
      }
      if ((missingMethodMatch = message.match(/has no method '(.*?)'/)) || message.match(/is not a function/) || message.match(/has no method/)) {
        if (missingMethodMatch) {
          target = missingMethodMatch[1];
        } else if (range != null) {
          codeSnippet = code.substring(range[0].ofs, range[1].ofs);
          missingMethodMatch = this.methodRegex.exec(codeSnippet);
          if (missingMethodMatch != null) {
            target = missingMethodMatch[1];
          }
        }
        hint = target != null ? this.getNoFunctionHint(target) : void 0;
      } else if (missingReference = message.match(/([^\s]+) is not defined/)) {
        hint = this.getReferenceErrorHint(missingReference[1]);
      } else if (missingProperty = message.match(/Cannot (?:read|call) (?:property|method) '([\w]+)' of (?:undefined|null)/)) {
        hint = this.getReferenceErrorHint(missingProperty[1]);
        if ((hint == null) && (range != null)) {
          line = code.substring(range[0].ofs - range[0].col, code.indexOf('\n', range[1].ofs));
          nullObjRegex = new RegExp("(\\w+)\\." + missingProperty[1]);
          if (nullObjMatch = nullObjRegex.exec(line)) {
            hint = "'" + nullObjMatch[1] + "' was null. Use a null check before accessing properties. Try `if " + nullObjMatch[1] + ":`";
          }
        }
      }
      return hint;
    };

    HintCreator.prototype.getNoFunctionHint = function(target) {
      var hint,
        _this = this;
      hint = this.getNoCaseMatch(target, this.context.thisMethods, function(match) {
        return "Uppercase or lowercase problem. Try `" + _this.thisValueAccess + match + "()`";
      });
      if (hint == null) {
        hint = this.getScoreMatch(target, [
          {
            candidates: this.context.thisMethods,
            msgFormatFn: function(match) {
              return "Try `" + _this.thisValueAccess + match + "()`";
            }
          }
        ]);
      }
      if (hint == null) {
        hint = this.getExactMatch(target, this.context.commonThisMethods, function(match) {
          return "You do not have an item equipped with the " + match + " skill.";
        });
      }
      if (hint == null) {
        hint = this.getNoCaseMatch(target, this.context.commonThisMethods, function(match) {
          return "Did you mean " + match + "? You do not have an item equipped with that skill.";
        });
      }
      if (hint == null) {
        hint = this.getScoreMatch(target, [
          {
            candidates: this.context.commonThisMethods,
            msgFormatFn: function(match) {
              return "Did you mean " + match + "? You do not have an item equipped with that skill.";
            }
          }
        ]);
      }
      if (hint == null) {
        hint = "You don't have a `" + target + "` method.";
      }
      return hint;
    };

    HintCreator.prototype.getReferenceErrorHint = function(target) {
      var hint, method, thisPrefixed, _ref3,
        _this = this;
      hint = this.getExactMatch(target, this.context.stringReferences, function(match) {
        return "Missing quotes. Try `\"" + match + "\"`";
      });
      if (hint == null) {
        hint = this.getExactMatch(target, this.context.thisMethods, function(match) {
          return "Try `" + _this.thisValueAccess + match + "()`";
        });
      }
      if (hint == null) {
        hint = this.getExactMatch(target, this.context.thisProperties, function(match) {
          return "Try `" + _this.thisValueAccess + match + "`";
        });
      }
      if ((hint == null) && target.toLowerCase() === this.thisValue.toLowerCase()) {
        hint = "Uppercase or lowercase problem. Try `" + this.thisValue + "`";
      }
      if (hint == null) {
        hint = this.getNoCaseMatch(target, this.context.stringReferences, function(match) {
          return "Missing quotes.  Try `\"" + match + "\"`";
        });
      }
      if (hint == null) {
        hint = this.getNoCaseMatch(target, this.context.thisMethods, function(match) {
          return "Try `" + _this.thisValueAccess + match + "()`";
        });
      }
      if (hint == null) {
        hint = this.getNoCaseMatch(target, this.context.thisProperties, function(match) {
          return "Try `" + _this.thisValueAccess + match + "`";
        });
      }
      if (hint == null) {
        hint = this.getScoreMatch(target, [
          {
            candidates: [this.thisValue],
            msgFormatFn: function(match) {
              return "Try `" + match + "`";
            }
          }, {
            candidates: this.context.stringReferences,
            msgFormatFn: function(match) {
              return "Missing quotes. Try `\"" + match + "\"`";
            }
          }, {
            candidates: this.context.thisMethods,
            msgFormatFn: function(match) {
              return "Try `" + _this.thisValueAccess + match + "()`";
            }
          }, {
            candidates: this.context.thisProperties,
            msgFormatFn: function(match) {
              return "Try `" + _this.thisValueAccess + match + "`";
            }
          }
        ]);
      }
      if (hint == null) {
        hint = this.getExactMatch(target, this.context.commonThisMethods, function(match) {
          return "You do not have an item equipped with the " + match + " skill.";
        });
      }
      if (hint == null) {
        hint = this.getNoCaseMatch(target, this.context.commonThisMethods, function(match) {
          return "Did you mean " + match + "? You do not have an item equipped with that skill.";
        });
      }
      if (hint == null) {
        hint = this.getScoreMatch(target, [
          {
            candidates: this.context.commonThisMethods,
            msgFormatFn: function(match) {
              return "Did you mean " + match + "? You do not have an item equipped with that skill.";
            }
          }
        ]);
      }
      if (!hint && target.toLowerCase().indexOf('enemy') > -1 && _.contains(this.context.thisMethods, 'findNearestEnemy')) {
        hint = "There is no `" + target + "`. Use `" + (this.newVariableTemplate({
          name: target
        })) + this.thisValueAccess + "findNearestEnemy()` first.";
      }
      if ((hint == null) && (((_ref3 = this.context) != null ? _ref3.thisMethods : void 0) != null)) {
        thisPrefixed = (function() {
          var _i, _len, _ref4, _results;
          _ref4 = this.context.thisMethods;
          _results = [];
          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
            method = _ref4[_i];
            _results.push(this.thisValueAccess + method);
          }
          return _results;
        }).call(this);
        hint = this.getScoreMatch(target, [
          {
            candidates: thisPrefixed,
            msgFormatFn: function(match) {
              return "Try `" + match + "()`";
            }
          }
        ]);
      }
      return hint;
    };

    HintCreator.prototype.getExactMatch = function(target, candidates, msgFormatFn) {
      if (candidates == null) {
        return;
      }
      if (__indexOf.call(candidates, target) >= 0) {
        return msgFormatFn(target);
      }
    };

    HintCreator.prototype.getNoCaseMatch = function(target, candidates, msgFormatFn) {
      var candidatesLow, index, s;
      if (candidates == null) {
        return;
      }
      candidatesLow = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = candidates.length; _i < _len; _i++) {
          s = candidates[_i];
          _results.push(s.toLowerCase());
        }
        return _results;
      })();
      if ((index = candidatesLow.indexOf(target.toLowerCase())) >= 0) {
        return msgFormatFn(candidates[index]);
      }
    };

    HintCreator.prototype.getScoreMatch = function(target, candidatesList) {
      var closestMatch, closestScore, match, matchScore, msg, set, _i, _j, _len, _len1, _ref3, _ref4, _ref5;
      if (string_score == null) {
        return;
      }
      _ref3 = ['', 0, ''], closestMatch = _ref3[0], closestScore = _ref3[1], msg = _ref3[2];
      for (_i = 0, _len = candidatesList.length; _i < _len; _i++) {
        set = candidatesList[_i];
        if (set.candidates != null) {
          _ref4 = set.candidates;
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            match = _ref4[_j];
            matchScore = match.score(target, scoreFuzziness);
            if (matchScore > closestScore) {
              _ref5 = [match, matchScore, set.msgFormatFn(match)], closestMatch = _ref5[0], closestScore = _ref5[1], msg = _ref5[2];
            }
          }
        }
      }
      if (closestScore >= acceptMatchThreshold) {
        return msg;
      }
    };

    return HintCreator;

  })();

}).call(this);
