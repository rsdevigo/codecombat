(function() {
  var addedGlobals, debugDumper, emptyAST, isStatement, makeYieldFilter, shouldFlow, updateState, upgradeEvaluator, _, _ref, _ref1, _ref2;

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  addedGlobals = require('./protectBuiltins').addedGlobals;

  isStatement = function(name) {
    return name !== 'Literal' && name !== 'Identifier' && name !== 'ThisExpression' && name !== 'BlockStatement' && name !== 'MemberExpression' && name !== 'FunctionExpression' && name !== 'LogicalExpression' && name !== 'BinaryExpression' && name !== 'UnaryExpression' && name !== 'Program';
  };

  shouldFlow = function(name) {
    return name !== 'IfStatement' && name !== 'WhileStatement' && name !== 'DoWhileStatement' && name !== 'ForStatement' && name !== 'ForInStatement' && name !== 'ForOfStatement';
  };

  updateState = function(aether, evaluator) {
    var astStack, bottom, f, frame_stack, n, p, rng, s, statementStack, top, variables, x, _base, _base1, _base2, _i, _j, _len, _ref3, _ref4;
    frame_stack = evaluator.frames;
    top = frame_stack[0];
    bottom = frame_stack[frame_stack.length - 1];
    if (aether.options.includeFlow) {
      if (bottom.flow == null) {
        bottom.flow = {
          statementsExecuted: 0,
          statements: []
        };
        if ((_base = aether.flow).states == null) {
          _base.states = [];
        }
        aether.flow.states.push(bottom.flow);
      }
    }
    if (aether.options.includeMetrics) {
      if ((_base1 = aether.metrics).statementsExecuted == null) {
        _base1.statementsExecuted = 0;
      }
      if ((_base2 = aether.metrics).callsExecuted == null) {
        _base2.callsExecuted = 0;
      }
    }
    astStack = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = frame_stack.length; _i < _len; _i++) {
        x = frame_stack[_i];
        if (x.ast != null) {
          _results.push(x.ast);
        }
      }
      return _results;
    })();
    statementStack = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = astStack.length; _i < _len; _i++) {
        x = astStack[_i];
        if (isStatement(x.type)) {
          _results.push(x);
        }
      }
      return _results;
    })();
    if (top.ast != null) {
      if (aether.options.includeMetrics && top.ast.type === 'CallExpression') {
        ++aether.metrics.callsExecuted;
      }
      if (isStatement(top.ast.type)) {
        if (aether.options.includeMetrics) {
          ++aether.metrics.statementsExecuted;
        }
        if (bottom.flow != null) {
          ++bottom.flow.statementsExecuted;
        }
        if ((bottom.flow != null) && shouldFlow(top.ast.type)) {
          f = {};
          if (aether._userInfo != null) {
            f.userInfo = _.cloneDeep(aether._userInfo);
          }
          if (!aether.options.noVariablesInFlow) {
            variables = {};
            for (s = _i = _ref3 = frame_stack.length - 2; _ref3 <= 0 ? _i <= 0 : _i >= 0; s = _ref3 <= 0 ? ++_i : --_i) {
              p = frame_stack[s];
              if (!(p && p.scope)) {
                continue;
              }
              _ref4 = Object.keys(p.scope.object.properties);
              for (_j = 0, _len = _ref4.length; _j < _len; _j++) {
                n = _ref4[_j];
                if (n[0] === '_') {
                  continue;
                }
                if (p.value) {
                  variables[n] = p.value.debugString;
                }
              }
            }
            f.variables = variables;
          }
          rng = top.ast.originalRange;
          if (rng) {
            f.range = [rng.start, rng.end];
          }
          f.type = top.ast.type;
          if (!!f.range) {
            return bottom.flow.statements.push(f);
          }
        }
      }
    }
  };

  module.exports.createFunction = function(aether, code) {
    var engine, error, esper, fx, fxName, messWithLoops, name, state, _i, _len, _ref3, _ref4, _ref5, _ref6;
    esper = (_ref3 = (_ref4 = (_ref5 = typeof window !== "undefined" && window !== null ? window.esper : void 0) != null ? _ref5 : typeof self !== "undefined" && self !== null ? self.esper : void 0) != null ? _ref4 : typeof global !== "undefined" && global !== null ? global.esper : void 0) != null ? _ref3 : require('esper.js');
    state = {};
    messWithLoops = false;
    if (aether.options.whileTrueAutoYield || aether.options.simpleLoops) {
      messWithLoops = true;
    }
    if (!aether.esperEngine) {
      aether.esperEngine = new esper.Engine({
        strict: aether.language.id !== 'python',
        foreignObjectMode: aether.options.protectAPI ? 'smart' : 'link',
        extraErrorInfo: true,
        yieldPower: 2,
        debug: aether.options.debug
      });
    }
    engine = aether.esperEngine;
    fxName = aether.options.functionName || 'foo';
    aether.language.setupInterpreter(engine);
    if (aether.language.injectCode != null) {
      engine.evalASTSync(aether.language.injectCode, {
        nonUserCode: true
      });
    } else {
      engine.evalSync('');
    }
    _ref6 = Object.keys(addedGlobals);
    for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
      name = _ref6[_i];
      engine.addGlobal(name, addedGlobals[name]);
    }
    upgradeEvaluator(aether, engine.evaluator);
    try {
      if (aether.language.usesFunctionWrapping()) {
        engine.evalASTSync(aether.ast);
        if (aether.options.yieldConditionally) {
          fx = engine.fetchFunction(fxName, makeYieldFilter(aether));
        } else if (aether.options.yieldAutomatically) {
          fx = engine.fetchFunction(fxName, function(engine) {
            return true;
          });
        } else {
          fx = engine.fetchFunctionSync(fxName);
        }
      } else {
        if (aether.options.yieldConditionally) {
          fx = engine.functionFromAST(aether.ast, makeYieldFilter(aether));
        } else if (aether.options.yieldAutomatically) {
          fx = engine.functionFromAST(aether.ast, function(engine) {
            return true;
          });
        } else {
          fx = engine.functionFromASTSync(aether.ast);
        }
      }
    } catch (_error) {
      error = _error;
      console.log('Esper: error parsing AST. Returning empty function.', error.message);
      if (aether.language.id === 'javascript') {
        error.message = "Couldn't understand your code. Are your { and } braces matched?";
      } else {
        error.message = "Couldn't understand your code. Do you have extra spaces at the beginning, or unmatched ( and ) parentheses?";
      }
      aether.addProblem(aether.createUserCodeProblem({
        error: error,
        code: aether.raw,
        type: 'transpile',
        reporter: 'aether'
      }));
      engine.evalASTSync(emptyAST);
    }
    return fx;
  };

  debugDumper = _.debounce(function(evaluator) {
    return evaluator.dumpProfilingInformation();
  }, 5000);

  makeYieldFilter = function(aether) {
    return function(engine, evaluator, e) {
      var currentMark, frame_stack, top, yieldValue;
      frame_stack = evaluator.frames;
      top = frame_stack[0];
      if ((e != null) && e.type === 'event' && e.event === 'loopBodyStart') {
        if (top.srcAst.type === 'WhileStatement' && top.srcAst.test.type === 'Literal') {
          if (aether.whileLoopMarker != null) {
            currentMark = aether.whileLoopMarker();
            if (currentMark === top.mark) {
              top.mark = currentMark + 1;
              return true;
            } else {
              top.mark = currentMark;
            }
          }
        }
      }
      if (aether._shouldYield) {
        yieldValue = aether._shouldYield;
        aether._shouldYield = false;
        if (frame_stack[1].type === 'loop') {
          frame_stack[1].didYield = true;
        }
        return true;
      }
      return false;
    };
  };

  module.exports.createThread = function(aether, fx) {
    var engine, internalFx;
    internalFx = esper.Value.getBookmark(fx);
    engine = aether.esperEngine.fork();
    upgradeEvaluator(aether, engine.evaluator);
    return engine.makeFunctionFromClosure(internalFx, makeYieldFilter(aether));
  };

  module.exports.upgradeEvaluator = upgradeEvaluator = function(aether, evaluator) {
    var executionCount;
    executionCount = 0;
    return evaluator.instrument = function(evalu, evt) {
      debugDumper(evaluator);
      if (++executionCount > aether.options.executionLimit) {
        throw new TypeError('Statement execution limit reached');
      }
      return updateState(aether, evalu, evt);
    };
  };

  emptyAST = {
    "type": "Program",
    "body": [
      {
        "type": "FunctionDeclaration",
        "id": {
          "type": "Identifier",
          "name": "plan",
          "range": [9, 13],
          "loc": {
            "start": {
              "line": 1,
              "column": 9
            },
            "end": {
              "line": 1,
              "column": 13
            }
          },
          "originalRange": {
            "start": {
              "ofs": -8,
              "row": 0,
              "col": -8
            },
            "end": {
              "ofs": -4,
              "row": 0,
              "col": -4
            }
          }
        },
        "params": [],
        "defaults": [],
        "body": {
          "type": "BlockStatement",
          "body": [
            {
              "type": "VariableDeclaration",
              "declarations": [
                {
                  "type": "VariableDeclarator",
                  "id": {
                    "type": "Identifier",
                    "name": "hero"
                  },
                  "init": {
                    "type": "ThisExpression"
                  }
                }
              ],
              "kind": "var",
              "userCode": false
            }
          ],
          "range": [16, 19],
          "loc": {
            "start": {
              "line": 1,
              "column": 16
            },
            "end": {
              "line": 2,
              "column": 1
            }
          },
          "originalRange": {
            "start": {
              "ofs": -1,
              "row": 0,
              "col": -1
            },
            "end": {
              "ofs": 2,
              "row": 1,
              "col": 1
            }
          }
        },
        "rest": null,
        "generator": false,
        "expression": false,
        "range": [0, 19],
        "loc": {
          "start": {
            "line": 1,
            "column": 0
          },
          "end": {
            "line": 2,
            "column": 1
          }
        },
        "originalRange": {
          "start": {
            "ofs": -17,
            "row": 0,
            "col": -17
          },
          "end": {
            "ofs": 2,
            "row": 1,
            "col": 1
          }
        }
      }
    ],
    "range": [0, 19],
    "loc": {
      "start": {
        "line": 1,
        "column": 0
      },
      "end": {
        "line": 2,
        "column": 1
      }
    },
    "originalRange": {
      "start": {
        "ofs": -17,
        "row": 0,
        "col": -17
      },
      "end": {
        "ofs": 2,
        "row": 1,
        "col": 1
      }
    }
  };

}).call(this);
