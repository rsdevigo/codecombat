(function() {
  var S, getFunctionNestingLevel, getImmediateParentOfType, getParents, getParentsOfTypes, makeCheckIncompleteMembers, makeCheckThisKeywords, makeGatherNodeRanges, ranges, statements, _, _ref, _ref1, _ref2,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  S = require('esprima').Syntax;

  ranges = require('./ranges');

  statements = [S.EmptyStatement, S.ExpressionStatement, S.BreakStatement, S.ContinueStatement, S.DebuggerStatement, S.DoWhileStatement, S.ForStatement, S.FunctionDeclaration, S.ClassDeclaration, S.IfStatement, S.ReturnStatement, S.SwitchStatement, S.ThrowStatement, S.TryStatement, S.VariableStatement, S.WhileStatement, S.WithStatement, S.VariableDeclaration];

  getParents = function(node) {
    var parents;
    parents = [];
    while (node.parent) {
      parents.push(node = node.parent);
    }
    return parents;
  };

  getParentsOfTypes = function(node, types) {
    return _.filter(getParents(node), function(elem) {
      var _ref3;
      return _ref3 = elem.type, __indexOf.call(types, _ref3) >= 0;
    });
  };

  getFunctionNestingLevel = function(node) {
    return getParentsOfTypes(node, [S.FunctionExpression]).length;
  };

  getImmediateParentOfType = function(node, type) {
    while (node) {
      if (node.type === type) {
        return node;
      }
      node = node.parent;
    }
  };

  module.exports.makeGatherNodeRanges = makeGatherNodeRanges = function(nodeRanges, code, codePrefix) {
    return function(node) {
      if (!node.range) {
        return;
      }
      node.originalRange = ranges.offsetsToRange(node.range[0], node.range[1], code, codePrefix);
      if (node.source) {
        node.originalSource = node.source();
      } else {

      }
      return nodeRanges.push(node);
    };
  };

  module.exports.makeCheckThisKeywords = makeCheckThisKeywords = function(globals, varNames, language, problemContext) {
    return function(node) {
      var hint, message, p, param, problem, range, v, _i, _j, _k, _len, _len1, _len2, _ref3, _ref4, _ref5, _ref6, _results;
      if (node.type === S.VariableDeclarator) {
        return varNames[node.id.name] = true;
      } else if (node.type === S.AssignmentExpression) {
        return varNames[node.left.name] = true;
      } else if (node.type === S.FunctionDeclaration || node.type === S.FunctionExpression) {
        if (node.id != null) {
          varNames[node.id.name] = true;
        }
        _ref3 = node.params;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          param = _ref3[_i];
          _results.push(varNames[param.name] = true);
        }
        return _results;
      } else if (node.type === S.CallExpression) {
        v = node;
        while ((_ref4 = v.type) === S.CallExpression || _ref4 === S.MemberExpression) {
          v = v.object != null ? v.object : v.callee;
        }
        v = v.name;
        if (v && !varNames[v] && !(__indexOf.call(globals, v) >= 0)) {
          if (!problemContext) {
            return;
          }
          _ref5 = getParentsOfTypes(node, [S.FunctionDeclaration, S.FunctionExpression, S.VariableDeclarator, S.AssignmentExpression]);
          for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
            p = _ref5[_j];
            if (p.id != null) {
              varNames[p.id.name] = true;
            }
            if (p.left != null) {
              varNames[p.left.name] = true;
            }
            if (p.params != null) {
              _ref6 = p.params;
              for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
                param = _ref6[_k];
                varNames[param.name] = true;
              }
            }
            if (varNames[v] === true) {
              return;
            }
          }
          if (/\$$/.test(v)) {
            return;
          }
          if (((problemContext != null ? problemContext.thisMethods : void 0) != null) && __indexOf.call(problemContext.thisMethods, v) < 0) {
            return;
          }
          message = "Missing `hero` keyword; should be `" + language.heroValueAccess + v + "`.";
          hint = "There is no function `" + v + "`, but `hero` has a method `" + v + "`.";
          if (node.originalRange) {
            range = language.removeWrappedIndent([node.originalRange.start, node.originalRange.end]);
          }
          problem = this.createUserCodeProblem({
            type: 'transpile',
            reporter: 'aether',
            kind: 'MissingThis',
            message: message,
            hint: hint,
            range: range
          });
          return this.addProblem(problem);
        }
      }
    };
  };

  module.exports.makeCheckIncompleteMembers = makeCheckIncompleteMembers = function(language, problemContext) {
    return function(node) {
      var exp, hint, kind, m, problem, range, _ref3, _ref4;
      if (node.type === 'ExpressionStatement') {
        exp = node.expression;
        if (exp.type === 'MemberExpression') {
          if (exp.property.name === "IncompleteThisReference") {
            kind = 'IncompleteThis';
            m = "this.what? (Check available spells below.)";
            return hint = '';
          } else if (exp.object.source() === language.thisValue) {
            kind = 'NoEffect';
            m = "" + (exp.source()) + " has no effect.";
            if (((problemContext != null ? problemContext.thisMethods : void 0) != null) && (_ref3 = exp.property.name, __indexOf.call(problemContext.thisMethods, _ref3) >= 0)) {
              m += " It needs parentheses: " + (exp.source()) + "()";
            } else if (((problemContext != null ? problemContext.commonThisMethods : void 0) != null) && (_ref4 = exp.property.name, __indexOf.call(problemContext.commonThisMethods, _ref4) >= 0)) {
              m = "" + (exp.source()) + " is not currently available.";
            } else {
              hint = "Is it a method? Those need parentheses: " + (exp.source()) + "()";
            }
            if (node.originalRange) {
              range = language.removeWrappedIndent([node.originalRange.start, node.originalRange.end]);
            }
            problem = this.createUserCodeProblem({
              type: 'transpile',
              reporter: 'aether',
              message: m,
              kind: kind,
              hint: hint,
              range: range
            });
            return this.addProblem(problem);
          }
        }
      }
    };
  };

}).call(this);
