(function() {
  var JavaScript, Language, acorn_loose, escodegen, esprima, jshintHolder, traversal, _, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  jshintHolder = {};

  esprima = require('esprima');

  acorn_loose = require('acorn/acorn_loose');

  escodegen = require('escodegen');

  Language = require('./language');

  traversal = require('../traversal');

  module.exports = JavaScript = (function(_super) {
    __extends(JavaScript, _super);

    JavaScript.prototype.name = 'JavaScript';

    JavaScript.prototype.id = 'javascript';

    JavaScript.prototype.parserID = 'esprima';

    JavaScript.prototype.thisValue = 'this';

    JavaScript.prototype.thisValueAccess = 'this.';

    JavaScript.prototype.heroValueAccess = 'hero.';

    function JavaScript() {
      var _ref3;
      JavaScript.__super__.constructor.apply(this, arguments);
      if (jshintHolder.jshint == null) {
        jshintHolder.jshint = ((_ref3 = typeof self !== "undefined" && self !== null ? self.aetherJSHint : void 0) != null ? _ref3 : require('jshint')).JSHINT;
      }
    }

    JavaScript.prototype.obviouslyCannotTranspile = function(rawCode) {
      var e;
      try {
        eval("'use strict;'\nthrow 0;" + rawCode);
      } catch (_error) {
        e = _error;
        if (e !== 0) {
          return true;
        }
      }
      return false;
    };

    JavaScript.prototype.hasChangedASTs = function(a, b) {
      var aAST, bAST, options, removeLocations, _ref3, _ref4, _ref5;
      options = {
        loc: false,
        range: false,
        comment: false,
        tolerant: true
      };
      _ref3 = [null, null], aAST = _ref3[0], bAST = _ref3[1];
      try {
        aAST = esprima.parse(a, options);
      } catch (_error) {}
      try {
        bAST = esprima.parse(b, options);
      } catch (_error) {}
      if ((!aAST || !bAST) && (aAST || bAST)) {
        return true;
      }
      if (aAST && bAST) {
        if (((_ref4 = aAST.errors) != null ? _ref4 : []).length !== ((_ref5 = bAST.errors) != null ? _ref5 : []).length) {
          return true;
        }
        return !_.isEqual(aAST.body, bAST.body);
      }
      options = {
        locations: false,
        tabSize: 4,
        ecmaVersion: 5
      };
      aAST = acorn_loose.parse_dammit(a, options);
      bAST = acorn_loose.parse_dammit(b, options);
      if (!(aAST && bAST)) {
        console.log("Couldn't even loosely parse; are you sure " + a + " and " + b + " are " + this.name + "?");
        return true;
      }
      removeLocations = function(node) {
        if (node) {
          return node.start = node.end = null;
        }
      };
      traversal.walkAST(aAST, removeLocations);
      traversal.walkAST(bAST, removeLocations);
      return !_.isEqual(aAST, bAST);
    };

    JavaScript.prototype.replaceLoops = function(rawCode) {
      var a, convertedCode, line, lineNumber, lines, rangeIndex, replacedLoops, start, _i, _len, _ref3;
      if (rawCode.indexOf('loop') === -1) {
        return [rawCode, []];
      }
      convertedCode = "";
      replacedLoops = [];
      rangeIndex = 0;
      lines = rawCode.split('\n');
      for (lineNumber = _i = 0, _len = lines.length; _i < _len; lineNumber = ++_i) {
        line = lines[lineNumber];
        if (line.replace(/^\s+/g, "").indexOf('loop') === 0) {
          start = line.indexOf('loop');
          a = line.split("");
          [].splice.apply(a, [start, (start + 3) - start + 1].concat(_ref3 = 'while (true)'.split(""))), _ref3;
          line = a.join("");
          replacedLoops.push(rangeIndex + start);
        }
        convertedCode += line;
        if (lineNumber !== lines.length - 1) {
          convertedCode += '\n';
        }
        rangeIndex += line.length + 1;
      }
      return [convertedCode, replacedLoops];
    };

    JavaScript.prototype.lint = function(rawCode, aether) {
      var c, e, error, firstParen, firstSemiColon, g, i, jshintGlobals, jshintOptions, jshintSuccess, line, lines, lintProblems, offset, parenCount, row, wrappedCode, _i, _j, _k, _len, _len1, _len2, _ref3, _ref4;
      lintProblems = [];
      if (!jshintHolder.jshint) {
        return lintProblems;
      }
      wrappedCode = this.wrap(rawCode, aether);
      jshintOptions = {
        browser: false,
        couch: false,
        devel: false,
        dojo: false,
        jquery: false,
        mootools: false,
        node: false,
        nonstandard: false,
        phantom: false,
        prototypejs: false,
        rhino: false,
        worker: false,
        wsh: false,
        yui: false
      };
      jshintGlobals = _.zipObject(jshintGlobals, (function() {
        var _i, _len, _ref3, _results;
        _ref3 = aether.allGlobals;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          g = _ref3[_i];
          _results.push(false);
        }
        return _results;
      })());
      try {
        jshintSuccess = jshintHolder.jshint(wrappedCode, jshintOptions, jshintGlobals);
      } catch (_error) {
        e = _error;
        console.warn("JSHint died with error", e);
      }
      _ref3 = jshintHolder.jshint.errors;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        error = _ref3[_i];
        lintProblems.push(aether.createUserCodeProblem({
          type: 'transpile',
          reporter: 'jshint',
          error: error,
          code: wrappedCode,
          codePrefix: this.wrappedCodePrefix
        }));
      }
      if (_.isEmpty(lintProblems)) {
        lines = rawCode.split(/\r\n|[\n\r\u2028\u2029]/g);
        offset = 0;
        for (row = _j = 0, _len1 = lines.length; _j < _len1; row = ++_j) {
          line = lines[row];
          if (/^\s*if /.test(line)) {
            if ((firstParen = line.indexOf('(')) >= 0) {
              parenCount = 1;
              _ref4 = line.slice(firstParen + 1, +line.length + 1 || 9e9);
              for (i = _k = 0, _len2 = _ref4.length; _k < _len2; i = ++_k) {
                c = _ref4[i];
                if (c === '(') {
                  parenCount++;
                }
                if (c === ')') {
                  parenCount--;
                }
                if (parenCount === 0) {
                  break;
                }
              }
              i += firstParen + 1 + 1;
              if (parenCount === 0 && /^[ \t]*;/.test(line.slice(i, +line.length + 1 || 9e9))) {
                firstSemiColon = line.indexOf(';');
                lintProblems.push({
                  type: 'transpile',
                  reporter: 'aether',
                  level: 'warning',
                  message: "Don't put a ';' after an if statement.",
                  range: [
                    {
                      ofs: offset + firstSemiColon,
                      row: row,
                      col: firstSemiColon
                    }, {
                      ofs: offset + firstSemiColon + 1,
                      row: row,
                      col: firstSemiColon + 1
                    }
                  ]
                });
                break;
              }
            }
          }
          offset += line.length + 1;
        }
      }
      return lintProblems;
    };

    JavaScript.prototype.beautify = function(rawCode, aether) {
      var ast, beautified, e;
      try {
        ast = esprima.parse(rawCode, {
          range: true,
          tokens: true,
          comment: true,
          tolerant: true
        });
        ast = escodegen.attachComments(ast, ast.comments, ast.tokens);
      } catch (_error) {
        e = _error;
        console.log('got error beautifying', e);
        ast = acorn_loose.parse_dammit(rawCode, {
          tabSize: 4,
          ecmaVersion: 5
        });
      }
      beautified = escodegen.generate(ast, {
        comment: true,
        parse: esprima.parse
      });
      return beautified;
    };

    JavaScript.prototype.usesFunctionWrapping = function() {
      return false;
    };

    JavaScript.prototype.hackCommonMistakes = function(code, aether) {
      code = code.replace(/this\.\s*?\n/g, "this.IncompleteThisReference;");
      return code;
    };

    JavaScript.prototype.parse = function(code, aether) {
      var ast, errors, x;
      ast = esprima.parse(code, {
        range: true,
        loc: true,
        tolerant: true
      });
      errors = [];
      if (ast.errors) {
        errors = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = ast.errors;
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            x = _ref3[_i];
            if (x.description !== 'Illegal return statement') {
              _results.push(x);
            }
          }
          return _results;
        })();
        delete ast.errors;
      }
      if (errors[0]) {
        throw errors[0];
      }
      return ast;
    };

    JavaScript.prototype.parseDammit = function(code, aether) {
      var ast, fixNodeRange, lines, locToRange, posToOffset;
      ast = acorn_loose.parse_dammit(code, {
        locations: true,
        tabSize: 4,
        ecmaVersion: 5
      });
      if ((ast != null) && ast.body.length !== 1) {
        ast.body = ast.body.slice(0, 0);
      }
      ast;
      lines = code.replace(/\n/g, '\n空').split('空');
      posToOffset = function(pos) {
        return _.reduce(lines.slice(0, pos.line - 1), (function(sum, line) {
          return sum + line.length;
        }), 0) + pos.column;
      };
      locToRange = function(loc) {
        return [posToOffset(loc.start), posToOffset(loc.end)];
      };
      fixNodeRange = function(node) {
        if (node && node.loc) {
          return node.range = locToRange(node.loc);
        }
      };
      traversal.walkAST(ast, fixNodeRange);
      return ast;
    };

    return JavaScript;

  })(Language);

}).call(this);
