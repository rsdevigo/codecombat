(function() {
  var Language, Python, parserHolder, traversal, _, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  parserHolder = {};

  traversal = require('../traversal');

  Language = require('./language');

  module.exports = Python = (function(_super) {
    var selfToThis;

    __extends(Python, _super);

    Python.prototype.name = 'Python';

    Python.prototype.id = 'python';

    Python.prototype.parserID = 'filbert';

    Python.prototype.thisValue = 'self';

    Python.prototype.thisValueAccess = 'self.';

    Python.prototype.heroValueAccess = 'hero.';

    Python.prototype.wrappedCodeIndentLen = 4;

    function Python() {
      var _ref3, _ref4, _ref5;
      Python.__super__.constructor.apply(this, arguments);
      this.injectCode = require('aether-lang-stdlibs/python-stdlib.ast.json');
      this.indent = Array(this.wrappedCodeIndentLen + 1).join(' ');
      if (((_ref3 = parserHolder.parser) != null ? _ref3.pythonRuntime : void 0) == null) {
        if (parserHolder.parser != null) {
          console.log('Aether python parser ONLY missing pythonRuntime');
        }
        parserHolder.parser = (_ref4 = typeof self !== "undefined" && self !== null ? self.aetherFilbert : void 0) != null ? _ref4 : require('skulpty');
        if (!parserHolder.parser.pythonRuntime) {
          console.error("Couldn't import Python runtime; our filbert import only gave us", parserHolder.parser);
        }
      }
      if (parserHolder.parserLoose == null) {
        parserHolder.parserLoose = (_ref5 = typeof self !== "undefined" && self !== null ? self.aetherFilbertLoose : void 0) != null ? _ref5 : require('skulpty');
      }
      this.runtimeGlobals = {
        __pythonRuntime: parserHolder.parser.pythonRuntime
      };
    }

    Python.prototype.hasChangedASTs = function(a, b) {
      var aAST, bAST, error, options, _ref3;
      try {
        _ref3 = [null, null], aAST = _ref3[0], bAST = _ref3[1];
        options = {
          locations: false,
          ranges: false
        };
        aAST = parserHolder.parserLoose.parse_dammit(a, options);
        bAST = parserHolder.parserLoose.parse_dammit(b, options);
        if (!(aAST && bAST)) {
          return true;
        }
        return !_.isEqual(aAST, bAST);
      } catch (_error) {
        error = _error;
        return true;
      }
    };

    Python.prototype.replaceLoops = function(rawCode) {
      var a, convertedCode, end, line, lineNumber, lines, problems, rangeIndex, start, _i, _len, _ref3;
      if (!rawCode.match(/^\s*loop/m)) {
        return [rawCode, []];
      }
      convertedCode = "";
      this.replacedLoops = [];
      problems = [];
      rangeIndex = 0;
      lines = rawCode.split('\n');
      for (lineNumber = _i = 0, _len = lines.length; _i < _len; lineNumber = ++_i) {
        line = lines[lineNumber];
        if (line.match(/^\s*loop\b/, "") && lineNumber < lines.length - 1) {
          start = line.indexOf('loop');
          end = start + 4;
          while (end < line.length && line[end].match(/\s/)) {
            end++;
          }
          if (line[end] !== ':') {
            problems.push({
              type: 'transpile',
              message: "You are missing a ':' after 'loop'. Try `loop:`",
              range: [
                {
                  row: lineNumber,
                  column: start
                }, {
                  row: lineNumber,
                  column: end
                }
              ]
            });
          }
          a = line.split("");
          [].splice.apply(a, [start, end - start + 1].concat(_ref3 = 'while True:'.split(""))), _ref3;
          line = a.join("");
          this.replacedLoops.push(rangeIndex + start);
        }
        convertedCode += line;
        if (lineNumber !== lines.length - 1) {
          convertedCode += '\n';
        }
        rangeIndex += line.length + 1;
      }
      return [convertedCode, this.replacedLoops, problems];
    };

    Python.prototype.lint = function(rawCode, aether) {
      var ast, error, problems,
        _this = this;
      problems = [];
      try {
        ast = parserHolder.parser.parse(rawCode, {
          locations: true,
          ranges: true,
          allowReturnOutsideFunction: true
        });
        traversal.walkASTCorrect(ast, function(node) {
          if (node.type !== "WhileStatement") {
            return;
          }
          if (node.body.body.length !== 0) {
            return;
          }
          return problems.push({
            type: 'transpile',
            reporter: 'aether',
            level: 'warning',
            message: "Empty loop. Put 4 spaces in front of statements inside loops.",
            range: [
              {
                ofs: node.range[0],
                row: node.loc.start.line - 1,
                col: node.loc.start.column
              }, {
                ofs: node.range[1],
                row: node.loc.end.line - 1,
                col: node.loc.end.column
              }
            ]
          });
        });
        if (problems.length === 0) {
          traversal.walkASTCorrect(ast, function(node) {
            if (node.type !== "IfStatement") {
              return;
            }
            if (node.consequent.body.length !== 0) {
              return;
            }
            return problems.push({
              type: 'transpile',
              reporter: 'aether',
              level: 'warning',
              message: "Empty if statement. Put 4 spaces in front of statements inside the if statement.",
              range: [
                {
                  ofs: node.range[0],
                  row: node.loc.start.line - 1,
                  col: node.loc.start.column
                }, {
                  ofs: node.range[1],
                  row: node.loc.end.line - 1,
                  col: node.loc.end.column
                }
              ]
            });
          });
        }
      } catch (_error) {
        error = _error;
      }
      return problems;
    };

    Python.prototype.usesFunctionWrapping = function() {
      return false;
    };

    Python.prototype.removeWrappedIndent = function(range) {
      range = _.cloneDeep(range);
      return range;
    };

    Python.prototype.parse = function(code, aether) {
      var ast;
      ast = parserHolder.parser.parse(code, {
        locations: false,
        ranges: true,
        allowReturnOutsideFunction: true
      });
      selfToThis(ast);
      return ast;
    };

    Python.prototype.parseDammit = function(code, aether) {
      var ast, error;
      try {
        ast = parserHolder.parserLoose.parse_dammit(code, {
          locations: false,
          ranges: true
        });
        selfToThis(ast);
      } catch (_error) {
        error = _error;
        ast = {
          type: "Program",
          body: [
            {
              "type": "EmptyStatement"
            }
          ]
        };
      }
      return ast;
    };

    Python.prototype.convertToNativeType = function(obj) {
      if (!(obj != null ? obj._isPython : void 0) && _.isArray(obj)) {
        parserHolder.parser.pythonRuntime.utils.convertToList(obj);
      }
      if (!(obj != null ? obj._isPython : void 0) && _.isObject(obj)) {
        parserHolder.parser.pythonRuntime.utils.convertToDict(obj);
      }
      return obj;
    };

    Python.prototype.cloneObj = function(obj, cloneFn) {
      var k, result, v, _i, _len;
      if (cloneFn == null) {
        cloneFn = function(o) {
          return o;
        };
      }
      if (_.isArray(obj)) {
        result = new parserHolder.parser.pythonRuntime.objects.list();
        for (_i = 0, _len = obj.length; _i < _len; _i++) {
          v = obj[_i];
          result.append(cloneFn(v));
        }
      } else if (_.isObject(obj)) {
        result = new parserHolder.parser.pythonRuntime.objects.dict();
        for (k in obj) {
          v = obj[k];
          result[k] = cloneFn(v);
        }
      } else {
        result = cloneFn(obj);
      }
      return result;
    };

    selfToThis = function(ast) {
      ast.body.unshift({
        "type": "VariableDeclaration",
        "declarations": [
          {
            "type": "VariableDeclarator",
            "id": {
              "type": "Identifier",
              "name": "self"
            },
            "init": {
              "type": "ThisExpression"
            }
          }
        ],
        "kind": "var",
        "userCode": false
      });
      return ast;
    };

    Python.prototype.setupInterpreter = function(esper) {
      var realm;
      realm = esper.realm;
      return realm.options.linkValueCallReturnValueWrapper = function(value) {
        var ArrayPrototype, defineProperties, gen, it, listPropertyDescriptor;
        ArrayPrototype = realm.ArrayPrototype;
        if (value.jsTypeName !== 'object') {
          return value;
        }
        if (value.clazz === 'Array') {
          defineProperties = realm.Object.getImmediate('defineProperties');
          listPropertyDescriptor = realm.globalScope.get('__pythonRuntime').getImmediate('utils').getImmediate('listPropertyDescriptor');
          gen = defineProperties.call(realm.Object, [value, listPropertyDescriptor], realm.globalScope);
          it = gen.next();
          while (!it.done) {
            it = gen.next();
          }
        }
        return value;
      };
    };

    return Python;

  })(Language);

}).call(this);
