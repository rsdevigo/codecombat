(function() {
  var CoffeeScript, Language, StructuredCode, estraverse, fixLocations, parserHolder, _, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  parserHolder = {};

  estraverse = require('estraverse');

  Language = require('./language');

  module.exports = CoffeeScript = (function(_super) {
    __extends(CoffeeScript, _super);

    CoffeeScript.prototype.name = 'CoffeeScript';

    CoffeeScript.prototype.id = 'coffeescript';

    CoffeeScript.prototype.parserID = 'csredux';

    CoffeeScript.prototype.thisValue = '@';

    CoffeeScript.prototype.thisValueAccess = '@';

    CoffeeScript.prototype.heroValueAccess = 'hero.';

    CoffeeScript.prototype.wrappedCodeIndentLen = 4;

    function CoffeeScript() {
      var _ref3;
      CoffeeScript.__super__.constructor.apply(this, arguments);
      this.indent = Array(this.wrappedCodeIndentLen + 1).join(' ');
      if (parserHolder.csredux == null) {
        parserHolder.csredux = (_ref3 = typeof self !== "undefined" && self !== null ? self.aetherCoffeeScriptRedux : void 0) != null ? _ref3 : require('coffee-script-redux');
      }
    }

    CoffeeScript.prototype.wrap = function(rawCode, aether) {
      var indentedCode, line;
      if (this.wrappedCodePrefix == null) {
        this.wrappedCodePrefix = "" + (aether.options.functionName || 'foo') + " = (" + (aether.options.functionParameters.join(', ')) + ") ->\n\n";
      }
      if (this.wrappedCodeSuffix == null) {
        this.wrappedCodeSuffix = '\n';
      }
      indentedCode = ((function() {
        var _i, _len, _ref3, _results;
        _ref3 = rawCode.split('\n');
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          line = _ref3[_i];
          _results.push(this.indent + line);
        }
        return _results;
      }).call(this)).join('\n');
      return this.wrappedCodePrefix + indentedCode + this.wrappedCodeSuffix;
    };

    CoffeeScript.prototype.removeWrappedIndent = function(range) {
      range = _.cloneDeep(range);
      range[0].ofs -= this.wrappedCodeIndentLen * range[0].row;
      range[1].ofs -= this.wrappedCodeIndentLen * range[1].row;
      return range;
    };

    CoffeeScript.prototype.parse = function(code, aether) {
      var csAST, jsAST;
      csAST = parserHolder.csredux.parse(code, {
        optimise: false,
        raw: true
      });
      jsAST = parserHolder.csredux.compile(csAST, {
        bare: true
      });
      fixLocations(jsAST);
      return jsAST;
    };

    return CoffeeScript;

  })(Language);

  StructuredCode = (function() {
    function StructuredCode(code) {
      var _ref3;
      _ref3 = this.generateOffsets(code), this.cursors = _ref3[0], this.indentations = _ref3[1];
      this.length = this.cursors.length;
    }

    StructuredCode.prototype.generateOffsets = function(code) {
      var cursor, indentations, reg, res, result, _ref3, _ref4;
      reg = /(?:\r\n|[\r\n\u2028\u2029])/g;
      result = [0];
      indentations = [0];
      while (res = reg.exec(code)) {
        cursor = res.index + res[0].length;
        reg.lastIndex = cursor;
        result.push(cursor);
        indentations.push((_ref3 = code.substr(cursor).match(/^\s+/)) != null ? (_ref4 = _ref3[0]) != null ? _ref4.length : void 0 : void 0);
      }
      return [result, indentations];
    };

    StructuredCode.prototype.column = function(offset) {
      return this.loc(offset).column;
    };

    StructuredCode.prototype.line = function(offset) {
      return this.loc(offset).line;
    };

    StructuredCode.prototype.fixRange = function(range, loc) {
      var fix;
      fix = Math.floor(this.indentations[loc.start.line - 1] + 5 / 4);
      range[0] -= fix;
      range[1] -= fix;
      return range;
    };

    StructuredCode.prototype.loc = function(offset) {
      var column, index, line;
      index = _.sortedIndex(this.cursors, offset);
      if (this.cursors.length > index && this.cursors[index] === offset) {
        column = 0;
        line = index + 1;
      } else {
        column = offset - 4 - this.cursors[index - 1];
        line = index;
      }
      return {
        column: column,
        line: line
      };
    };

    return StructuredCode;

  })();

  fixLocations = function(program) {
    var structured;
    structured = new StructuredCode(program.raw);
    return estraverse.traverse(program, {
      leave: function(node, parent) {
        var loc;
        if (node.range != null) {
          loc = {
            start: null,
            end: structured.loc(node.range[1])
          };
          if (node.loc != null) {
            loc.start = node.loc.start;
          } else {
            loc.start = structured.loc(node.range[0]);
          }
          if (_.isNaN(loc.end.column)) {
            loc.end.column = loc.start.column + 1;
          }
          node.loc = loc;
          if (node.range[1] == null) {
            node.range[1] = node.range[0] + 1;
          }
          node.range = structured.fixRange(node.range, loc);
        } else {
          node.loc = (function() {
            var _ref3;
            switch (node.type) {
              case 'BlockStatement':
                if (node.body.length) {
                  return {
                    start: node.body[0].loc.start,
                    end: node.body[node.body.length - 1].loc.end
                  };
                } else {
                  return parent.loc;
                }
                break;
              case 'VariableDeclarator':
                if ((node != null ? (_ref3 = node.init) != null ? _ref3.loc : void 0 : void 0) != null) {
                  return {
                    start: node.id.loc.start,
                    end: node.init.loc.end
                  };
                } else {
                  return node.id.loc;
                }
                break;
              case 'ExpressionStatement':
                return node.expression.loc;
              case 'ReturnStatement':
                if (node.argument != null) {
                  return node.argument.loc;
                } else {
                  return node.loc;
                }
                break;
              case 'VariableDeclaration':
                return {
                  start: node.declarations[0].loc.start,
                  end: node.declarations[node.declarations.length - 1].loc.end
                };
              default:
                return {
                  start: {
                    line: 0,
                    column: 0
                  },
                  end: {
                    line: 0,
                    column: 0
                  }
                };
            }
          })();
        }
      }
    });
  };

}).call(this);
