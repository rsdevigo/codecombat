(function() {
  var Language, Lua, parserHolder, ranges,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Language = require('./language');

  ranges = require('../ranges');

  parserHolder = {};

  module.exports = Lua = (function(_super) {
    __extends(Lua, _super);

    Lua.prototype.name = 'Lua';

    Lua.prototype.id = 'lua';

    Lua.prototype.parserID = 'lua2js';

    Lua.prototype.heroValueAccess = 'hero:';

    function Lua() {
      var _ref;
      Lua.__super__.constructor.apply(this, arguments);
      if (parserHolder.lua2js == null) {
        parserHolder.lua2js = (_ref = typeof self !== "undefined" && self !== null ? self.aetherLua2JS : void 0) != null ? _ref : require('lua2js');
      }
      this.runtimeGlobals = parserHolder.lua2js.stdlib;
      this.injectCode = require('aether-lang-stdlibs/lua-stdlib.ast.json');
      this.fidMap = {};
    }

    Lua.prototype.obviouslyCannotTranspile = function(rawCode) {
      return false;
    };

    Lua.prototype.callParser = function(code, loose) {
      var ast;
      ast = parserHolder.lua2js.parse(code, {
        loose: loose,
        forceVar: false,
        decorateLuaObjects: true,
        luaCalls: true,
        luaOperators: true,
        encloseWithFunctions: false
      });
      return ast;
    };

    Lua.prototype.replaceLoops = function(rawCode) {
      var a, convertedCode, line, lineNumber, lines, rangeIndex, replacedLoops, start, _i, _len, _ref;
      if (rawCode.indexOf('loop') === -1) {
        return [rawCode, []];
      }
      convertedCode = "";
      replacedLoops = [];
      rangeIndex = 0;
      lines = rawCode.split('\n');
      for (lineNumber = _i = 0, _len = lines.length; _i < _len; lineNumber = ++_i) {
        line = lines[lineNumber];
        if (line.replace(/^\s+/g, "").indexOf('loop') === 0) {
          start = line.indexOf('loop');
          a = line.split("");
          [].splice.apply(a, [start, (start + 3) - start + 1].concat(_ref = 'while true do'.split(""))), _ref;
          line = a.join("");
          replacedLoops.push(rangeIndex + start);
        }
        convertedCode += line;
        if (lineNumber !== lines.length - 1) {
          convertedCode += '\n';
        }
        rangeIndex += line.length + 1;
      }
      return [convertedCode, replacedLoops];
    };

    Lua.prototype.lint = function(rawCode, aether) {
      var ast, e, error, lintProblems, rng, _i, _len, _ref;
      lintProblems = [];
      try {
        ast = this.callParser(rawCode, true);
      } catch (_error) {
        e = _error;
        return [];
        return [
          aether.createUserCodeProblem({
            type: 'transpile',
            reporter: 'lua2js',
            error: e,
            code: rawCode,
            codePrefix: ""
          })
        ];
      }
      _ref = ast.errors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        error = _ref[_i];
        rng = ranges.offsetsToRange(error.range[0], error.range[1], rawCode, '');
        lintProblems.push(aether.createUserCodeProblem({
          type: 'transpile',
          reporter: 'lua2js',
          message: error.msg,
          code: rawCode,
          codePrefix: "",
          range: [rng.start, rng.end]
        }));
      }
      return lintProblems;
    };

    Lua.prototype.usesFunctionWrapping = function() {
      return false;
    };

    Lua.prototype.wrapResult = function(ast, name, params) {
      ast.body.unshift({
        "type": "VariableDeclaration",
        "declarations": [
          {
            "type": "VariableDeclarator",
            "id": {
              "type": "Identifier",
              "name": "self"
            },
            "init": {
              "type": "ThisExpression"
            }
          }
        ],
        "kind": "var",
        "userCode": false
      });
      return ast;
    };

    Lua.prototype.parse = function(code, aether) {
      var ast;
      ast = Lua.prototype.wrapResult(Lua.prototype.callParser(code, false), aether.options.functionName, aether.options.functionParameters);
      return ast;
    };

    Lua.prototype.parseDammit = function(code, aether) {
      var ast, error;
      try {
        ast = Lua.prototype.wrapResult(Lua.prototype.callParser(code, true), aether.options.functionName, aether.options.functionParameters);
        return ast;
      } catch (_error) {
        error = _error;
        return {
          "type": {
            "BlockStatement": {
              body: [
                {
                  type: "EmptyStatement"
                }
              ]
            }
          }
        };
      }
    };

    Lua.prototype.pryOpenCall = function(call, val, finder) {
      var node, target;
      node = call.right;
      if (val[1] !== "__lua") {
        return null;
      }
      if (val[2] === "call") {
        target = node["arguments"][1];
        return finder(target);
      }
      if (val[2] === "makeFunction") {
        this.fidMap[node["arguments"][0].name] = finder(call.left);
      }
      return null;
    };

    Lua.prototype.rewriteFunctionID = function(fid) {
      return this.fidMap[fid] || fid;
    };

    return Lua;

  })(Language);

}).call(this);
